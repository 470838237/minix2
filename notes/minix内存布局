1  bios load master boot to 0x07f00

|-------------------|0x100000
|    ............   |
|-------------------|0x08100
|     master boot   |
|-------------------|0x07f00
|   ............    |
|-------------------|0x00
|    BIOS数据区以及   |
|    端口号存放区     |
|-------------------|0x00600
|      中断向量      |
|-------------------|0x00000

2 copy master boot to 0x00600 from 0x07f00
and load bootblock from disk to 0x07f00

|-------------------|0x100000
|   ............    |
|-------------------|0x08100
|     bootblock     |
|-------------------|0x07f00
|   .............   |
|-------------------|0x00800
|   master boot     |
|-------------------|0x00600
|    BIOS数据区以及   |
|    端口号存放区     |
|-------------------|0x00400
|      中断向量      |
|-------------------|0x00000

3 bootblock load boot from disk to 0x10000

|-------------------|0x100000
|   ............    |
|-------------------|0x10000+boot_size(boot_size<=64 sectors)
|   boot(header)    |
|-------------------|0x10000
|   ............    |
|-------------------|0x08100
|     bootblock     |
|-------------------|0x07f00
|   .............   |
|-------------------|0x00800
|   master boot     |
|-------------------|0x00600
|    BIOS数据区以及   |
|    端口号存放区     |
|-------------------|0x00400
|      中断向量      |
|-------------------|0x00000

4  copy boot from 0x10000 to newaddr and relocate
runsize = text + data + bss + heap + stack

|-------------------|0x100000
|   ............    |
|-------------------|0xf0000            copy
|       boot        |<---------------------------------------------|
| (exclude header)  |                                              |
|-------------------|newaddr = 0xf0000-runsize                     |
|                   |                                              |
|-------------------|                                              |
|   ............    |                                              |
|-------------------|0x10000+boot_size(boot_size<=64 sectors)      |
|       boot        |                                              |
| (include header)  |----------------------------------------------|
|-------------------|0x10000
|   ............    |
|-------------------|0x08100
|     bootblock     |
|-------------------|0x07f00
|   .............   |
|-------------------|0x00800
|   master boot     |
|-------------------|0x00600
|    BIOS数据区以及   |
|    端口号存放区     |
|-------------------|0x00400
|      中断向量      |
|-------------------|0x00000

5 boot load minix kernel image
minix kernel image  override 0x00800 to newaddr

|-------------------|0x100000
|   ............    |
|-------------------|0xf0000
|       boot        |
| (exclude header)  |
|-------------------|newaddr = 0xf0000-runsize-------------------------------------|
|   image header    |  size =   16*32                                              |
| ----------------  |aout addr = newaddr - 16*32                                   |
|                   |size = mem[1]=newaddr - 2048
|    image zone     |
|                   |
|  ---------------- | click_size对齐
|   kernel   stack  |
|  ---------------- | click_size对齐
|   kernel   bss    |
|  ---------------- | click_size对齐
|   kernel   data   | flag&A_SEP==0 时data包含text和data,并且text和data之间没有click_size对齐
|  ---------------- | click_size对齐
|   kernel   text   | flag&A_PAL==1时 text包含image_header
|-------------------|kernel_cs_start_adr=  (0x00800+click_size-1)&~(click_size-1)
|   ............    |
|-------------------|0x00800 = mem[0] = 0+2048---|
|   master boot     |
|-------------------|0x00600
|    BIOS数据区以及   |
|    端口号存放区     |
|-------------------|0x00400
|      中断向量      |
|-------------------|0x00000


minix内存管理:

free_slot(未分配slot链表指针头)hole_head(已分配hole链表指针头)
hole[proc_nr*2]
                         /|\
|-------------------|     |next_free_slot=NULL
|      2*proc_nr-1  |<----|
|-------------------|     |next_free_slot=proc_nr-1
|     2*proc_nr-2   |<----|
|-------------------|     |next_free_slot=proc_nr-2
|     ......        |<----|
|-------------------|     |next_free_slot=2
|         1         |<----|
|-------------------|     |next_free_slot=1
|         0         |-----|
|-------------------|
初始状态: free_slot=&hole[0], hole_head=NULL

增加1个hole后:
                         /|\
|-------------------|     |next_free_slot=NULL
|      2*proc_nr-1  |<----|
|-------------------|     |next_free_slot=proc_nr-1
|     2*proc_nr-2   |<----|
|-------------------|     |next_free_slot=proc_nr-2
|     ......        |<----|
|-------------------|     |next_free_slot=2
|         1         |<----|
|------------------|
|         0         |
|-------------------|
free_slot=&hole[1], hole_head=&hole[0]

增加1个hole后:
                         /|\
|-------------------|     |next_free_slot=NULL
|      2*proc_nr-1  |<----|
|-------------------|     |next_free_slot=proc_nr-1
|     2*proc_nr-2   |<----|
|-------------------|     |next_free_slot=proc_nr-2
|     ......        |<----|
|-------------------|
|         1         |<----|
|-------------------|     |next_hole=1
|         0         |-----|
|-------------------|

free_slot=&hole[2], hole_head=&hole[0]


在内存4g内存机器上且开启内存交换后初始化Hole表结构可能如下:
                         /|\
|-------------------|     |next_free_slot=NULL
|      2*proc_nr-1  |<----|
|-------------------|     |next_free_slot=proc_nr-1
|     2*proc_nr-2   |<----|
|-------------------|     |next_free_slot=proc_nr-2
|     ......        |<----|
|-------------------|
|3(4g,4g6+swap_size)|<----|next_hole=NULL
|-------------------|     |next_hole=3
|      2(16-4096M)  |<----|
|-------------------|     |next_hole=2
|      1(1-16M)     |<----|
|-------------------|     |next_hole=1
|      0(0-1M)      |-----|
|-------------------|


fork()
1 父进程请求MM,此时父进程阻塞在sendrec系统调用
2 mm收到请求后查看mproc数组是否有free slot,存在就找到free slot的索引即proc_nr
3 根据父进程mproc计算出fork子进程需要的分配的内存空间大小，然后申请是否有满足的空余内存
4 如果有空余内存则将父进程的mproc属性拷贝到子进程mproc并修改子进程内存映射地址，为子进程分配一个未使用的进程号
5 通知sys_task 复制内核父进程proc属性子进程对应的proc中,复制需要恢复p_ldt_sel，因为p_ldt_sel和proc的索引绑定关系到局部描述的加载，
  不能直接复制父进程的局部描述符选择子。同时清除一些其他属性
6 通知fs复制父进程fproc属性到子进程fproc以实现文件描述符共享，同时修改其他属性
7 通知内核更新新的内存映射，从新设置局部描述符表，如果子进程proc的p_flags为0则加入到就绪队列，但是由于子进程拷贝了父进程的属性值
  且第5部清除p_flags标志位中不包含RECEIVING，因此子进程p_flags继承了父进程RECEIVING标志位，执行ready的条件并为触发，子进程依然在阻塞队列
8 先对子进程调用setreply然后在对父进程调用setreply，然后分别对父进程和子进程调用send以解除阻塞加入到就绪队列等待调度。由于迭代mproc时
  不能保证父进程或子进程先后熟顺序，因此不能保证send的调用顺序，因此也不能保证父子进程被唤醒的先后顺序

brk(addr)
1 初始breaksize为endbss的大小在此基础上进行内存分配。内存管理都是以CLICK_SIZE为单位，先检查new_clicks是否小于数据段基地址
  当大于数据段基地址后再检查其他情况，如果申请的大小合法则调整数据段的大小和栈的基地址和大小
2 数据段和栈之间留有安全的空隙大小SAFETY_BYTES，即数据段的末尾+SAFETY_BYTES不能超过栈的基址
3 当前栈的基地址为栈指针和栈基址的最小值，栈基址在每次成功调用brk时刷新，栈基址只能变小不能变大
4 检查栈指针和栈基址的最小值<数据段末尾地址+SAFETY_BYTES,如果成立则数据段和栈段冲突，返回错误
5 当数据段和栈段未冲突时，判断数据段末尾地址是否发生变化，变化时更新数据段大小。
6 判断栈段的基址是否发生变化，发生变化更新栈基址，栈大小，栈物理基址
7 通知内核更新proc程序地址映射表
8 如果第7不调用失败恢复第6,7步的变更

execve(const char *path, char * const *argv, char * const *envp)
1 调用系统调用_syscall(MM, EXEC, &m);先在当前子进程调用sbrk申请内存，然后拷贝参数到分配的连续内存中。
分配的大小为argv数组的字符串大小(包含字符串结束符)+envp数组存储的字符串大小(包含字符串结束符)+argv指针数组大小+envp指针数组大小+sizeof(argc)+sizeof(0)*2
内存布局可以查阅《操作系统设计与实现》图4-39
2 mm检查参数，并将子进程参数复制到mm数据段中
3 检查文件是否是可执行文件还是shell脚本，如果是脚本则读取shell的可执行文件路径，然后在读取可执行文件header，同时将可执行文件路径patch到mm栈中
4 搜寻当前子进程是否和其他进程共享内存映射文本段，根据结果决定是否释放当前内存映射文本段
5 查询是否有其他进程共享可执行文件文本段，然后根据第3不读取的头文件计算需要为进程分配内存空间大小。并通知内核空间内存映射，然后将新分配的内存清0
6 根据第5新分配内存栈地址patch mm栈传即将传递给启动程序的栈空间。
7 拷贝MM可执行文件参数到为可执行程序栈内存
8 根据当前可执行文件是否共享文本段拷贝程序到内存中
9 重置进程信号响应行为为默认行为
10 通知文件系统根据待关闭位图关闭进程文件
11 设置内核进程名为可执行文件名