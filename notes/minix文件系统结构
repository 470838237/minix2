                                                        disk
                                                          |
                                                          |
  |--------------------------|----------------------------|-------------------------------|------------------------|
  |                          |                            |                               |                        |
sector1(mbr)            disk-part1                  disk-part2(active)              disk-part3              disk-part4
  |                         /|\                          /|\                             /|\                      /|\
  |                          |                            |                               |                        |
  |                     table entry1                 table entry2                   table entry3            table entry4
  |                          |                            |                               |                        |
  |                          |----------------------------|-------------------------------|------------------------|
  |                                                       |
  |                                                       |
  | byte: [0-446)                                    [446,446+16*4)                                             [510,511]
  |  master boot code                                 partition table                                          sign:0xAA55
  |     |--------------------------------------------------|-------------------------------------------------------|
  |                                                       /|\
  |                                                        |
  |                                                        |
  |                                                        |
  |--------------------------------------------------------|

  table entry:
  struct part_entry {
    unsigned char bootind;	/* boot indicator 0/ACTIVE_FLAG	 */
    unsigned char start_head;	/* head value for first sector	 */
    unsigned char start_sec;	/* sector value + cyl bits for first sector */
    unsigned char start_cyl;	/* track value for first sector	 */
    unsigned char sysind;		/* system indicator		 */
    unsigned char last_head;	/* head value for last sector	 */
    unsigned char last_sec;	/* sector value + cyl bits for last sector */
    unsigned char last_cyl;	/* track value for last sector	 */
    unsigned long lowsec;		/* logical first sector		 */
    unsigned long size;		/* size of partition in sectors	 */
  };


                                                           disk-partition
                                                                 |
                                                                 |
         |--------------------------|----------------------------|-------------------------------|------------------------|-------------------|------------------|
         |                          |                            |                               |                        |                   |                  |
sector: [0-1]                      [2-3]                        [4-5]
block:   0                          1                        blocks used by                      3                  blocks used by       blocks used         blocks used
      boot block                 super block                 inode bit map                    no use(未使用)         zone bit map        by file inode         by file
                                                                                                                                   (root dir['/'] node number = 1)
struct:                          super_block                                                                                            d1_inode/d2_inode

typedef struct {		/* V1.x disk inode */
  mode_t d1_mode;		/* file type, protection, etc. */
  uid_t d1_uid;			/* user id of the file's owner */
  off_t d1_size;		/* current file size in bytes */
  time_t d1_mtime;		/* when was file data last changed */
  u8_t d1_gid;			/* group number */
  u8_t d1_nlinks;		/* how many links to this file */
  u16_t d1_zone[V1_NR_TZONES];	/* block nums for direct, ind, and dbl ind */
} d1_inode;
/* Declaration of the V2 inode as it is on the disk (not in core). */
//磁盘中inode节点
typedef struct {		/* V2.x disk inode */
  mode_t d2_mode;		/* file type, protection, etc. */
  u16_t d2_nlinks;		/* how many links to this file. HACK! */
  uid_t d2_uid;			/* user id of the file's owner. */
  u16_t d2_gid;			/* group number HACK! */
  off_t d2_size;		/* current file size in bytes */
  time_t d2_atime;		/* when was file data last accessed */
  time_t d2_mtime;		/* when was file data last changed */
  time_t d2_ctime;		/* when was inode data last changed */
  zone_t d2_zone[V2_NR_TZONES];	/* block nums for direct, ind, and dbl ind */
} d2_inode;
EXTERN struct buf {
  /* Data portion of the buffer. */
  union {
    char b__data[BLOCK_SIZE];		     /* ordinary user data */
    struct direct b__dir[NR_DIR_ENTRIES];    /* directory block */
    zone1_t b__v1_ind[V1_INDIRECTS];	     /* V1 indirect block */
    zone_t  b__v2_ind[V2_INDIRECTS];	     /* V2 indirect block */
    d1_inode b__v1_ino[V1_INODES_PER_BLOCK]; /* V1 inode block */
    d2_inode b__v2_ino[V2_INODES_PER_BLOCK]; /* V2 inode block */
    bitchunk_t b__bitmap[BITMAP_CHUNKS];     /* bit map block */
  } b;

  /* Header portion of the buffer. */
  struct buf *b_next;		/* used to link all free bufs in a chain */
  struct buf *b_prev;		/* used to link all free bufs the other way */
  struct buf *b_hash;		/* used to link bufs on hash chains */
  block_t b_blocknr;		/* block number of its (minor) device */
  dev_t b_dev;			/* major | minor device where block resides */
  char b_dirt;			/* CLEAN or DIRTY */
  char b_count;			/* number of users of this buffer */
} buf[NR_BUFS];
EXTERN struct super_block {
  ino_t s_ninodes;		/* # usable inodes on the minor device */
  zone1_t  s_nzones;		/* total device size, including bit maps etc */
  short s_imap_blocks;		/* # of blocks used by inode bit map */
  short s_zmap_blocks;		/* # of blocks used by zone bit map */
  zone1_t s_firstdatazone;	/* number of first data zone */
  short s_log_zone_size;	/* log2 of blocks/zone */
  off_t s_max_size;		/* maximum file size on this device */
  short s_magic;		/* magic number to recognize super-blocks */
  short s_pad;			/* try to avoid compiler-dependent padding */
  zone_t s_zones;		/* number of zones (replaces s_nzones in V2) */

  /* The following items are only used when the super_block is in memory. */
  struct inode *s_isup;		/* inode for root dir of mounted file sys */
  struct inode *s_imount;	/* inode mounted on */
  unsigned s_inodes_per_block;	/* precalculated from magic number */
  dev_t s_dev;			/* whose super block is this? */
  int s_rd_only;		/* set to 1 iff file sys mounted read only */
  int s_native;			/* set to 1 iff not byte swapped file system */
  int s_version;		/* file system version, zero means bad magic */
  int s_ndzones;		/* # direct zones in an inode */
  int s_nindirs;		/* # indirect zones per indirect block */
  bit_t s_isearch;		/* inodes below this bit number are in use */
  bit_t s_zsearch;		/* all zones below this bit number are in use*/
} super_block[NR_SUPERS];

struct direct {
  ino_t d_ino;
  char d_name[DIRSIZ];
}


                                         |-------------------> dir inode(d1_inode/d2_inode)
                                         |                               |定位
                                         |                              \|/
                                         |               根据d2_zone和d2_size定位 dir content block position
                                         |                               |解析dir content block
                                         |                              \|/
                                         |                 dir content block存储的结构单元direct
                                         |                               |定位 d_ino
                                         |                              \|/
                                         |                       inode(d1_inode/d2_inode)
                                         |             dir               |d2_mode?isdir
                                         |-------------------------------|
                                                                         |
                                                                         |file
                                                                        \|/
                                                             根据d2_zone和d2_size定位file data


zone_shift
V2_NR_TZONES  10
nr_dzones = 7

find block_position;
vir_block:
zone = block_t >> zone_shift
zone_index = vir_block - (zone<<zone_shift)
dzones_array:

                                        zone < nr_dzones
                                                |
                 yes                            |                       no
|-----------------------------------------------------------------------------------------------|
|  block_position =   ind_zone_array[zone]<<zone_shift +  zone_index                            |
|----------------------------------------|                                                      |
                                         |                                                      |
----------------------------------------\|/-----------------------------------------| nr_dzones | nr_dzones+1
|      0           1           2           3           4           5           6    |      7    |      8           9
|-----------|-----------|-----------|-----------|-----------|-----------|-----------|----------\|/-----------|-----------|
|           |           |           |           |           |           |           | ind_zone  |ind_ind_zone|           |
|-----------|-----------|-----------|-----------|-----------|-----------|-----------|-----------|------------|-----------|
                                                                                    |                        |
                                                                                    |                        |
                                                                                    |-----------|------------|
                                                                                                |
                                                                                       zone = zone - nr_dzones
                                                                                          zone  <  nr_indirects
                                                                                                |
                                                                                      yes       |      no
                                                                              |-----------------|-----------------|
                                                                              |                                   |
                                                                              |                                   |
                                                                              |                                   |
                                                                           ind_zone                           ind_ind_zone
                                                                              |                                   |                                                                                          |
indirect zone_t array : ind_zone_array                                        |                                   |
ind_zone_array_length= BLOCK_SIZE/V2_ZONE_NUM_SIZE = 256                      |                                   |
                             zone                                             |                                   |
      0           1         ......       253         254        255           |                                   |
|-----------|-----------|--- --------|-----------|-----------|-----------|    |                                   |
|           |           |ind_zone_num|           |           |           |    |                                   |
|-----------|-----------|-- --/|\----|-----------|-----------|-----------|    |                                   |
                               |                                              |                                   |
                               |----------------------------------------------|                                   |
                                block =   ind_zone<<zone_shift                |                                   |
                                 buf  = readblock(block)                      |                                   |
                                 ind_zone_array = cast(buf)                   |                                   |
 block_position =   ind_zone_array[zone]<<zone_shift +  zone_index            |                                   |
                                                                              |                                   |
                                 |--------------------------------------------|                                   |
indirect zone_t array :          |                                                                                |
ind_ind_zone_array               |                                                                                |
ind_ind_zone_array_length=       |                                                                                |
ind_zone_array_length            |                                                                                |
      0           1           ...|...         253         254        255                                          |
|-----------|-----------|--------|-------|-----------|-----------|-----------|                                    |
|           |           |  ind_zone_num  |           |           |           |                                    |
|-----------|-----------|-------/|\------|-----------|-----------|-----------|                                    |
                                 |                                                                                |                                                                                                                  |
                                 |--------------------------------------------------------------------------------|
                                              block =  ind_ind_zone<<zone_shift
                                              buf  = readblock(block)
                                              ind_ind_zone_array = cast(buf)
                                              i = zone/nr_indirects
                                              zone = zone%nr_indirects
                                              ind_zone_num = ind_ind_zone_array[i]

file block offset from disk-partition : s_bfpblock;
file inode number: t_ifile;
boot block size : s_bblock
super block size: s_sblock
no use          : s_nblock
blocks used by inode bit map size:s_uibblock
blocks used by inode bit map size:s_uzbblock
inodes per block : s_ipb;
inode offset of block : s_ioob;
s_bfpblock = s_bblock + s_sblock + s_nblock + s_uibblock + s_uzbblock + (t_ifile-1)/s_ipb
s_ioob = (t_ifile-1)%s_ipb







文件系统挂载:
假设当前设备/dev/sda1,设备号1,文件系统用户目录为/usr,usr节点号为10
主机其他未挂载设备挂/dev/sdb1,设备号5,文件系统根节点号1
此时将/dev/sdb1挂载至/dev/sda1文件系统,挂在到/usr目录下,/usr为挂载点
inode(1,10)为挂载点/usr在内存中和磁盘中的节点
inode(5,1)为被挂载文件系统/dev/sdb1根节点
super_block(1)为设备1的超级块在内存中数据,super_block(5)为设备5的超级块在内存中数据
此时super_block(5)中s_imount指向inode(1,10),s_isup指向inode(5,1)

当前路径为根路径/时,执行cd usr时的执行流程如下:
1 搜索/目录文件名为usr的节点即inode(1,10)
2 判断当前节点是否是其他设备的挂载点即inode.i_mount == I_MOUNT为true表示该节点是挂载点
3 搜索全局super_block匹配super_block.s_imount==inode(1,10)，匹配成功则找到被挂载设备超级块
4 通过被挂载设备超级块找到根节点，返回根节点，此时挂载点节点切换成功

当前路径为根路径/usr时,执行cd ..
1 /usr对应节点为inode(5,1),搜索该节点下文件名为..的节点，因为搜索路径为/usr/..由此可知当前节点为被挂载谁被根节点，此时需要切换至挂载点节点
2 搜索全局super_block匹配super_block.s_dev
3 匹配到super_block即可获得s_imount即inode(1,10)
4 通过inode(1,10)搜索文件名..即/


block special file 和 character special file对应inode的imode设备类型会被置位为I_BLOCK_SPECIAL和I_CHACRACTER_SPECIAL
inode的dev属性为文件所属文件系统所在的设备号,inode的zone数组存储文件的内容,普通文件即REGULAR类型文件是存储在磁盘上的普通文件
因此zone记录了文件在磁盘上的分布位置,对于lock special file 和 character special file而言,他们的文件内容并不存储在磁盘上
而是存储在设备文件对应的存储区域,因此需要根据设备的设备号对文件进行读写操作,因此将块设备文件的设备号存储在zone[0]位置用于定位
设备文件从而实现文件的读写


消息传递管道pipe: pipe(int fds[])
消息传递功能实现方式:
传递参数fd[0]表示从管道读取内容,fd[1]表示向管道写入内容,因为管道用于进程间消息传递,因此fd[0]和fd[1]为不同进程的文件描述符,通常在fork函数创建pipe
因此fd[0]和fd[1]为不同进程的文件描述符,文件描述符号指向不同的filp,但不同的filp的filp_ino指针指向相同inode节点,因此一个进程持有fd[1]文件描述符
向管道内写入内容也即写入共享的管道文件中,另一个进程持有fd[0]读取内容也即从共享管道文件读取内容。fd[0]指向的filp属性filp_mode为R_BIT,fd[1]指向
的filp属性filp_mode为W_BIT.
通过上述功能即可实现不同进程消息传递，但是管道消息传递还有以下特征:
1 管道是两个进程通信，但进程可能会在通信期间被结束的。当进程其中一个进程结束时会有如下表现
    1) 读取进程从管道中读取时,写进程不存在,读取操作立即返回
    2) 写进程向管道写入内容时,读取进程不存在,理解发送内核SIGPIPE信号
2 读写操作时读写进程都存在情况下根据管道文件读写操作发生阻塞
    1) 读取进程读取管道内容时发现管道文件为空,阻塞读取进程,并执行唤醒写进程操作
    2) 写入进程向管道写入内容时,如果要写入的内容超过管道文件限定大小,则写入大小为can_write = LIMIT_PIPE-position
       如果can_write大于0表示管道文件未满还可以继续向管道写入can_write大小,则执行唤醒读取进程操作,然后执行管道写入内容操作,写入完成后管道已满，此时阻塞写入进程
    3) can_write为0时表面管道文件已经满了不能继续向管道写入，此时阻塞写入进程

int fd2 = dup(fd):
为fd执行的文件分配新的描述符fd2,执行此操作后使用fd2和fd都是操作相同的文件
dup2(fd,fd2)
close文件描述符fd2执行的文件,并将fd2指向fd的文件,执行此操作后使用fd2和fd都是操作相同的文件



fproc.fp_cloexec:
fp_cloexec用于记录进程执行exec系统调用时需要关键的文件描述符。例如fp_cloexec第n位bit为1表示进程执行exec系统调用时关闭描述符为n的文件
第n位bit为0则不做处理
fcntl(fd, F_SETFD, 1);用于设置fd文件描述符对应fp_cloexec的bit位,为1时设置bit位,0表示清除该位
fcntl(fd, F_GETFD);获取fd文件描述符对应fp_cloexec的bit位值

fproc.filp_flags
用于记录O_NONBLOCK | O_APPEND | O_ACCMODE标志位
fcntl(ip_fd, F_SETFL, flags | O_NONBLOCK)
设置进程filp_flags标志位,只有设置O_NONBLOCK | O_APPEND标志位有效
fcntl(0,F_GETFL)获取filp_flags的O_NONBLOCK | O_APPEND | O_ACCMODE标志位


fcntl(fd,request,&flock)
flock.l_type:F_RDLCK,F_WRLCK,F_UNLCK
request:F_GETLK,F_SETLK,F_SETLKW
当request为F_GETLK时l_type不能为F_UNLCK
当flock指定fd文件范围内没有锁则设置flock的l_type为F_UNLCK
若flock指定fd文件范围内包含了其他锁的全部或者一部分时复制该锁属性至flock并返回,如果范围内存在多个锁也只返回找到的第一个锁

当request为F_SETLK,F_SETLKW时fd对应的文件读写属性必须包含l_type,如l_type为F_RDLCK时,fd必须设置了R_BIT或RW_BIT
当l_type为F_RDLCK,F_WRLCK时如果flock指定fd文件范围内包含了其他锁的全部或者一部分时发生冲突,此时request为F_SETLK直接返回错误
request为F_SETLKW时将当前操作进程挂起等待其他进程释放锁
如果flock指定fd文件范围内不包含其他锁且存在未使用锁槽时,将flock属性复制到空锁中对问价加锁
如果l_type未F_UNLCK时即释放flock范围内的锁,若范围内不存在其他锁则什么也不做。如果范围内存在其他锁则做如下判断:
设flock范围为[release_start,release_end],若锁lock1范围为[lock1_start,lock1_end]
如果release_start<lock1_start,lock1_start<release_end<lock1_end时，释放[lock1_start,release_end]范围
之前的锁范围变更为[release_end,lock1_end]
若锁lock2范围为[lock2_start,lock2_end]
如果release_end>lock2_end,lock2_start<release_start<lock2_end时释放[release_start,lock2_end]范围
之前的锁范围变更为[lock2_start,release_start]
若锁lock3范围为[lock3_start,lock3_end]
如果release_end<lock3_end且如果release_start>lock3_start时此时将产生两段文件锁，因此先判单是否有空的文件锁可以使用存在时释放锁[lock3_start,lock3_end]
并变更之前锁范围为[lock3_start,release_start],产生新锁范围为[release_end,lock3_end]
